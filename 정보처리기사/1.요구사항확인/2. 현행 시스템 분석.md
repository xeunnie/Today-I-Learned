# 현행 시스템 분석

## 현행 시스템 파악
어떤 하위 시스템으로 구성됐는지, 어떤 기술 요소를 사용하는지 파악하는 활동이다.
- 현행 시스템 파악 절차
    (1) 구성/기능/인터페이스 파악
    (2) 아키텍쳐 및 소프트웨어 구성 파악: 오픈소스인지, 상용소스인지, 라이센스 등 파악
    (3) 하드웨어 및 네트워크 구성 파악

- 소프트웨어 아키텍쳐
    소프트웨어 구성요소와 요소들의 특성, 요소들 간의 관계들을 정리한 것이다. 프레임워크보다 추상적인 개념이다.
- 소프트웨어 아키텍쳐 프레임워크
    실제 개발할 수 있도록 도구같은 것이 지원된 소프트웨어 템플릿이다.

- 소프트웨어 4+1뷰
    고객의 요구사항을 정리해놓은 시나리오를 4개의 관점으로 바라보는 접근방법이다.
    (1) 유스케이스뷰(usecase view): 다른 뷰를 검증하는 데에 사용되는 뷰다. 사용자, 설계자, 개발자, 테스트 관점이다.
    (2) 논리뷰(logical view): 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰다. 설계자, 개발자 관점이다.
    (3) 프로세스 뷰(process view): 비기능적인 속성으로서 자원의 사용, 실행, 처리 등을 표현한 뷰다. 개발자, 시스템 통합자 관점이다.
    (4) 구현 뷰 (implement view): 개발환경 안에서 정적인 모듈의 구성을 보여주는 뷰다. 부가적인 정보를 정의한다. 개발자 관점이다.
    (5) 배포 뷰(deployment): 컴포넌트가 물리적인 아키텍쳐에 어떻게 배지되는지 매핑해서 보여주는 뷰

- 소프트웨어 아키텍쳐 패턴
    sw를 설계할 떄, 참조할 수 있는 전형적인 해결방식
    (1) 계층화 패턴(layered pattern)
        시스템을 계층으로 구성하는 패턴이다. 서로 접한 계층 사이에서만 상호작용이 이뤄진다. 예시로는 OSI7계층이 있다.
    (2) 클라이언트-서버 패턴(client-server pattern)
        하나의 서버와 다수의 클아이언트로 구성된 패언이다. 사용자가 클라이언트를 통해 서버에 서비스를 요청하면 서버가 클라이언트를 통해서 제공한다.
    (3) 파이프 필터 패턴(pipe-filter pattern)
        서브 시스템이 입력 데이터를 처리하고 다름 서브 시스템으로 넘겨주는 과정이 반복된다. 데이터 스트림을 생성하고 처리하는 시스템에서 사용하는 패턴이다. 
    (4) 브로커 패턴(broker pattern)
        브로커가 중간에 중재자로 껴서 중간에 일을 처리해주고 상호작용해준다. 분리된 컴포넌트들로 이뤄진 분산 시스템에서 사용된다. 서버는 자신의 기능을 브로커에게 넘겨주면 브로커가 클라이언트의 요청에 따라 응답해주는 것이다.
    🌟(5) 모델-뷰-컨트롤러 패턴(MVC: model-view-controller pattern)
        모델, 뷰, 컨트롤러 3개의 서브시스템으로 구조화하는 패턴이다.
        * 모델: 핵심 기능과 데이터 보관한다.
        * 뷰: 사용자에게 정보 표시(하나 이상의 뷰가 정의됨)한다.
        * 컨트롤러: 사용자로부터 요청을 입력받아 처리한다.

- 소프트웨어 아키텍쳐 비용 평가 모델
    아키텍쳐 접근 법이 품질에 미치는 영향을 판단하고 적합성을 평가하는 모델이다.
    * 소프트웨어 아키텍쳐 비용 평가 모델 종류
    (1) SAAM(sw architechture analasys method):
        변경 용이성과 기능성에 집중하는 비용 평가 모델이다.
    (2) ATTAM(archtecture trade-off analasys method):
        품질 속성을 만족시키는지 판단하고 품질 속성들의 이해 상충관계를 평가하는 모델이다.
    (3) CBAM(cost benefit analasys method):
        atam을 바탕으로 시스템 아키텍쳐를 경제적인 초점에 맞춰 분석하는 모델이다.
    (4) ADR(active design review):
        응집도를 평가하는 모델이다.
    (5) ARID(active reviews for intermediate design):
        특정 부분만 품질 요서에 집중하는 평가모델이다.

## 디자인 패턴
소프트웨어 설계에서 공통으로 발생하는 문제에 대해 설계방법을 정리한 패턴이다. GoF라는 건축 패턴에서 따왔다.
- 디자인 패턴 구성 요소
    (1) 패턴의 이름 (2) 문제의 배경 (3) 솔루션 (4) 사례 (5) 결과 (6) 샘플 코드

- 디자인 패턴 유형(23가지)
    (1) 생성패턴: 인스턴스 생성에 관여한다.
        * 🌟생빌프로 팩앱싱:
            생성 / 빌더 / 프로토타입 / 팩토리 메서드 / 앱스트랙 팩토리 / 싱글턴
             * 빌더: 복잡한 인스턴스를 조립하여 만드는 구조다. 생성과 구현의 방법을 분리한다.
             * 프로토타입: 원형 복사해둔 후 필요한 부분만 수정한다.
             * 팩토리 매소드: 공장과 제품관계다. 상위클래스에서 인스턴스를 만드는 방법만 결정하고, 하위클래스에서 생성을 책임지고 조작하는 함수들을 오버라이딩 한다. 상위클래스에서 상속받는 것이 여러개다.
             * 앱스트랙 팩토리: 공장과 제품관계다. 상위 클래스에서 상속받는 것이 1개다. 구체적인 구현은 concrete product클래스에서 이뤄진다.
             * 싱클턴: 한 클래스에 한 객체만 존재하도록 한다. 전역변수를 사용하지 않고, 객체 하나만 생성하도록 한다. 생성된 객체는 참조할 수 있도록한다.
    (2) 구조패턴: 더 큰 구조 형성이 목적이다.
        * 🌟 구브데 퍼플 프록 컴어:
            구조 / 브리지/ 데코레이터 / 퍼사이드 / 플라이웨이트 / 프록시 / 컴포지트 / 어댑터
            * 브릿지: 기능의 클래스 계층과 구현의 클래스 계층을 연결해야한다.
            * 데코레이터: 기존에 구현된 클래스에 기능을 유연하게 추가해 나가는 설계다.
            * 퍼사이드(facade): 여타 시스템과의 결합도를 낯추는 것이다. 복잡한 내부를 단순한 인터페이스로 만드는 것이다.
            * 플라이웨이트: 모두가 갖는 본질적 요소를 클래스화 한다. 메모리를 절약하고 클래스 경량화를 이루기 위해 사용한다.
            * 프록시: 대리객체를 사용해 메모리 용량을 아낀다. 실제 객체에 접근하기 전에 대리 객체에 행동이 취해지는 방법이다.
            * 컴포지트: 객체 관계를 트리구조로 구성해 부분-전체 계층으로 표현하는 방법이다.
            * 어댑터: 클래스를 재사용할 수 있도록 중간역할을 하는 인터페이스를 만드는 방법이다.
    (3) 행위패턴: 상호작용하는 방법과 역할 분담을 다룬다.
        * 🌟 행미인이 뎁옵 스테 비커 스트 메체:
            행위 / 미디에이터 / 인터프리터 / 이터레이터 / 템플릿 메서드 / 옵져버 / 스테이트 / 비지터 / 커맨드 / 스트레티지 / 메멘토 / 체인 오브 리스폰서빌리티
            * 미디에이터: 중간에 통제하고 지시할 수 있는 중재자를 두어 중재자에게 모든 것을 요구하여 통신 빈도수를 줄이는 방법이다.
            * 인터프리터: 각 구문의 해석을 맡는 클래스를 작성해,  여러 형태의 언어 구문을 해석할 수 있게 한다.
            * 이터레이터: 반복자를 두어 모든 항목에 접근할 방법을 제공한다.
            * 템플릿 메소드: 일부분을 서브 클래스로 캡슐화 한다. 전체 일을 수행하는 구조는 바꾸지 않고 특정 단계에서 수행하는 내역을 바꾼다.
            * 옵져버: 한 객체의 상태가 바뀌면 타 객체들도 자동으로 내용이 갱신되도록 하는 방법이다.
            * 스테이트: 객체 상태를 캡슐화 해 클래스화 한다. 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경한다.
            * 비지터: 각 클래스를 돌아다니며서 특정 작업을 수행하도록 만드는 패턴이다.
            * 커맨드: 실행될 기능을 캡슐화 한다. 각 명령이 들어오면 그에 맞는 서브 클래스가 선택돼 실행된다.
            * 스트레티지: 같은 알고리즘을 하나의 클래스로 캡슐화 해서 서로 교환할 수 있도록 한다.
            * 메멘토: 객체의 정보를 저장해야할 때 적용한다. 작업취소(undo) 기능을 개발할 때 사용하는 패턴이다.
            * 체인 오브 리스폰서빌리티: 정적 처리 연결 시, 연결 변경이 불가능한데, 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결하는 것이다.

## 요구사항
- 요구공학
    요구가 반영된 시스템을 개발하기 위해 사용자의 요구사항에 대한 도출, 분석, 명세, 확인 검증하는 구조화된 활동이다.
    * 기능적 요구사항: 직관적 요구사항이다. 로그인과 같이 시스템이 반응해야하는지에 대한 기술이다. 기능성, 완전성, 일반성의 특징이 있다.
    * 비기능적 요구사항: 비직관적 요구사항이다. 보안기능과 같은 품질 속성과 관련된 기술이다. 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 품질관련, 제약사항 등이 있다.
-요구공학 프로세스
    * CMM(개발능력 성숙도 평가 및 프로세스 개선 활동을 하는 국제 표준 모델)레벨3
    [도출 -(명확화)-> 분석 -> 명세 <-(재작업)-> 확인 및 검증 -(수정 차이 해소)->도출]
        (1) 도출단계: 추상적 요구에 대한 식별 과정이다.
            - 인터뷰, 브레인스토밍, 델파이 기법, 롤플레잉, 워크숍, 설문조사
        (2) 분석단계: 충돌, 중복, 누락등의 분석을 통해 완전성과 일관성을 확보하는 과정이다.
            - 데이터 흐름도, 자료사전, UML
        (3) 명세단계: 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 과정이다.
            - 비정형 명세기법:자 연어 기반 서술 사용자와 개발자 이해 용이
            - 정형 명세기법: 수학적 표기법 사용, 정확
        (4) 확인 및 검증단계: 명세서에 올바르게 기술되었는지, 요구사항을 이애했는지 확인과 검증
            - 동료 검토, 워크스루(비공식적인 검토), 인스펙션(공식적인 검토)
    *CMM레벨2
    [요구사항 변경 관리, 추적 관리] - 협상, 기준선 정의, 변경 관리, 확인 및 검증
        (1) 요구사항 협상
        (2) 요구사항 기준선 설정
        (3) 요구사항 변경 관리: 형상통제 위원회
        (4) 요구사항 확인 및 검증