# 소프트웨어 개발방법론

## SDLC 프로세스
시스템의 전 공정의 절차를 말한다.
1. 요구사항 분석 - 기능/비기능 요구사항 고려, 제붐에 부합하는 요구조건 결정
2. 설계 - 명세 단계에서 정의한 기능 실제 수행할 수 있도록 논리적 결정(UI 설제, 구조 설계)
3. 구현 - 프로그래밍 단계, (인터페이스 개발, 자료구조 개발, 오류 처리)
4. 테스트 - 요수사한 만족하는지 테스트 (단위테스트, 통합테스트, 시스템 테스트, 인수 테스트)
5. 유지보수 - 인수되고 설치 후 운영하며 보수

### 소프트웨어 생명주기 모델 종류
1. 폭포수 모델(waterfall model)
각 단계를 확실히 마무리 지은 후 다음 단계로 넘어간다. 고전적인 방법으로, 수정이 어렵다.
2. 프로토타이핑 모델(prototype model)
주요 기능을 시제품 형태로 제작하여 고객의 피드백을 반영한다.
3. 나선형 모델(spiral model)
시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽하게 개발하는 모델이다. 일정이 늦어질 수 있는 단점이 있다.
[ 계획및 정의 / 위험 분석 / 개발 / 고객 평가 ] 이 과정을 계속 반복한다.
4. 반복적 모델(iteration model)
시스템을 쪼개 나누어 개발한다. 이후 통합하거나 반복적으로 개발해서 완성시킨다.

## 소프트웨어 개발 방법론
Software Development Methology
소웨 개발 전 과정에서 지속적으로 적용할 수 있는 방법이다.
SDLC(개발 단계)와는 다르게 각 방법론에 따라 개발 과정이 달라진다.

### 소프트웨어 개발 방법론 종류
1. 구조적 방법론(structured development)
기능에 초점을 맞추어 개발하는 방식이다. 전체 시스템을 기능에 따라 나눠 개발한 뒤 통합한다. 분할과 정복 방식의 방법론이라고도 한다.
하향식 방법론이다. 나씨-슈나이더만 차트(순차 구조, 선택 구조, 반복 구조)를 사용한다.

2. 정보 공학 방법론(information engineering development)
정보에 초점을 맞추어 개발하는 방식이다.

3. 객체 지향 방법론(object oriented devlopment)
객체 단위에 초점을 맞추어 개발하는 방식이다. 개체를 객체로(속성과 메서드가 결합된 형태) 표현하는 방식을 쓴다.
- 객체 지향 구성 요소
    * 클래스: 객체 내에 있는 변수와 메스드를 정의하는 틀이다. 데이터를 추상화 하는 단위다.
    * 객체: 클래스에서 정의한 틀에 따라 메모리가 할당된 각각의 대상을 말한다.
    * 메서드: 클래스로부터 생성된 객체를 사용하는 방법이다. 함수와 연산 기능을 담당한다.
    * 메시지: 객체간의 상호작용 수단으로 객체에서 객체로 전달된다.
    * 인스턴스: 클래스를 통해서 만든 실형 객체다. 실제 프로그래밍 상에서는 객체와 인스턴스 구별이 어렵다. new를 통해 생성된 클래스도 인스턴스에 해당한다. 실제 메모리 상에 할당된 것을 말한다.
    * 속성(property): 한 클래스 내에 속한 객체들이 가진 데이터값들을 단위별로 정의하는것을 말한다. 변수라고 불리는 것이 엄밀히 말하면 속성에 해당한다.
- 객체 지향 기법
    * 캡슐화(encapsulation): 접근성과 정보 은닉과 연관됐다. 연관된 데이터와 함수를 함계 묶어 외부와 경계를 만든다.
    * 상속성(inheritance): 상위 클래스의 속성과 메서드를 재정의 없이 물려받아 사용받는다.
    * 다형성(polymorphism): 하나의 메세지에 대해 객체가 가진 고유한 방법으로 응답하는 능력이다. 상속반은 여러 하위 객체들이 다른 형태의 특성을 가지는 객체로 이용할 수 있는 것을 말한다.
        (1) 오버로딩: 매개변수랑 메서드의 유형이나 갯수가 다를 때, 같은 이름의 메서드를 여러개 가지는 기법
        (2) 오버라이딩: 상위클래스에서 정의한 메서드를 하위 클래스에서 재정의하는 기법
    * 추상화(abstraction): 공통 성질을 추출해 추상 클래수를 설정하는 것을 말한다.
    * 정보은닉(informatoin hiding); 코드의 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근하게 하는 보안기술을 말한다. 모듈간의 독립성을 유지하는 데에 도움을 준다.
    * 관계성(relationship): 두개 이상의 엔터티 형에서 데이터를 참조하는 관계를 말한다.
        - 연관화(association): is-memeber-of 관계다. 같은 계층에 속하는 클래스 간에 비계층적인 연결로 참조 및 이용관계를말한다.
        - 집단화(aggregation): is-part-of, part-whole 관계다. 서로 관련있는 여러 객체를 묶는 것이다. 상위 클래스의 성질들이 하위 클래스로 상속되진 않는다.
        - 분류화(classification): is-instance-of 관계다. 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스다.
        - 일반화(generalization): is-a 관계다. 클래스 간의 개념적인 포함관계다.
        - 특수화(specialization): is-a관계다. 상위 클래스의 특성들을 상속 받으면서 하위 클래스에서 나름대로의 수정을 하고 자신만의 고유한 특성도 갖는 것을 말한다.
- 객체 지향 설계 원칙(SOLID)
    (1) 단일 책임의 원칙(SRP: single presponsibility)
    하나의 클래스는 하나의 목적을 위해서 생성돼야한다.
    (2). 개방 폐쇄의 원칙(OCP: open close principle)
    확장에는 열려있고 변경에는 닫혀있어야 한다.
    (3) 리스코프 치환의 원칙(LSP: liskov substitution principle)
    어디서나 자신의 상위 클래스로 교체할 수 있어야 한다는 원칙이다.
    (4) 인터페이스 분리의 원칙(ISP: interface segregation principle)
    사용하지 않는 인터페이스는 구현하지 않는다. 기능과 상관없는 부분의 변화에 영향을 받지 않아야 한다.
    (5) 의존성 역전의 원칙(DSP: dependency inversion principle)
    관계를 최대한 느슨하게 만드는 것이다. 클래스를 참조해서 사용할 때 직접 참조가 아닌 상위요소를 참조하는 것이다.
#### - 객체 지향 분석(OOA: object oriented analysis)
객체를 위해서 필요한 부분들을 분석하는 기법이다. (사용자의 요구사항을 분석해 문제와 관련된 모든것들의 관계를 정의하여 모델링하는 기법이다.)
    🌟(1) OOSE(object oriented software enginnering)
    야콥슨이 제작했다. 유스케이스를 모든 모델의 근간으로 사용한다. 기능적 요구사항 중심의 시스템이다.
    🌟(2) OMT(object modeling technology)
    럼바우가 제작했다. 그래픽 표기법을 이용하여 sw구성 요소를 모델링한다.
    분석절차 순서: 객체 모델링 -> 동적 모델링-> 기능 모델링
        * 객체 모델링(object modeling)/정보 모델링(information modeling)
        시스템에서 요구하는 객체를 찾고 객체간의 관계를 정의한다. ER다이어그램을
        * 동적 모델링(dynamic modeling)
        시간의 흐름에 따라 객체들 사이의 제어 흐름과 동작 순서 등 동적 행위를 표현한다.
        * 기능 모델링(functional modeling)
        DFD(자료 흐름도)를 활용하여 처리과정을 표현한다.
        DFD: 프로세스들의 자료 흐름을 중심으로 처리과정을 표현하는 모델링
    🌟(3) OOD(object oriented design)
    부치가 제작했다. 설계 문서화를 강조해 다이어그램 중심의 개발하는 방법론이다. 분석과 설계 분리가 불가능하다.
    (4) 코드와 요르돈 방법론(Coad-Yourdon)
    E-R다이어그램을 사용하여 객체의 행위를 모델링한다.
    ERD(entity relationship diagram): 개체간의 관계를 그린 다이어그림이다.
    개체는 네모, 관계는 마름모, 속성은 동그라미로 그린다.
    (5) 워프-브록 방법론(Wirfs-Brock)
    분석과 설계간 구분이 없다. 설계 작업까지 연속적으로 수행하는 분석 방법이다.

4. 컴포넌트 기반 방법론(CBD: compenent based development)
컴포넌트 단위에 초점을 맞추어 개발하는 방식이다. 컴포넌트를 조립해서 하나의 응용 프로그램을 작성한다. 개발 기간이 단축되고, 생산성이 향성되며 sw재사용이 가능하다.

#### 5. 애자일 방법론(agile development)
절차보다는 사람에 초점을 맞추어 개발하는 방식이다.
변화에 유연하게, 신속하게 적용하며 효율적으로 개발하는 방식이다.
신속 정응적 경량 개발 방법론이이라고 불린다. 폭포수 모델과 반대이다.
유동적으로 계획을 수립한다. 반복적 주기 단위로 개발을 수행한다. 팀 중심의 관리가 진행된다. 문서화보다는 코드를 중시한다. 계획 준수보다는 고객 가치 전달을 우선순위로 둔다. 유형으로는 xp, 스크럽, 린 등이 있다.(폭포수, 나선형, 프로토 타입과는 반대된다.)

6. 제품 개열 방법론(product line development)
특정 제품에 적용하고 싶은 공통 기능에 초점을 맞추어 개발한다. 임베디드 sw를 작정하는 데에 쓰임이 좋다.

7. XP(eXtreme Programming)
의사소통 개선과 즉작적 피드백으로 품질을 높이는 방법론이다. 1~3주의 개발주기를 가지며 5가지 가치와 12개의 실천항목을 가진다.
- 5개의 가치: 용기, 단순성, 의사소총, 피드백, 존중
- 12개의 실천항목:
짝 프로그래밍(pair programming), 공동코드 소유(collective ownership), 지속적인 통합(CI: continuous integration), 계획세우기(planning process), 작은 릴리즈(small release), 메타포어(metaphor 고객과 개발자 간의 의사소통 원활하게 하는 공통적 이름체계와 시스템 서술서), 간단한 디자인(simple sesign), 테스트기반 개발(TDD: test driven development), 리팩토링(refatoring), 40시간 작업(40hour work), 고객 상주(onsite customer), 코드 표준(coding standard)

8. 스크럼(scrum)
매일 정해진 시간 짧은 시간 개발하는 프로젝트 관리 방법론이다. 짧은 시간 개발하고 회고하는 것을 반복하는 방식이다.
- 주요 요소: 백로그(backlog 제품과 프로젝트 요구사항), 스프린트(sprint: 2~4주의 짧은 개발 기간, 반복적 수행), 스크럼 미팅, 스크럼 마스터, 스프린트 회고(sprint retrospective), 번다운 차트(burn down chart 백로그 대비 시간을 그래픽적으로 표현한 차트)

9. 린(lean)
도요타의 시스템품질기법을 개발 프로세스에 적용한 방법론이다. 낭비요소가 제거되는 것으로 JIT(just in time), 칸반보드를 사용한다.

### 프로젝트 관리
주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 활동
- PM(project manager) 프로젝트 관리자: 수행해야할 작업의 범위(scope), 자원, 업무, 비용 일정 등 관리
- 프로젝트 관리 대상: 계획 관리, 품질관리, 범위 관리
- 프로젝트 관리 3대 요소(3P): 사람, 문제, 프로세스

### 비용산정 모형
sw 규모 파악을 위한 투입자원, 소요 시간, 비용을 파악하는 모형이다.
- 하향식 산정방법: 전문가 판단(전문가 소수 판단), 델파이 기법(전문가 합의법)
- 상향식 산정방법: 요수사항 기능에 따라 비용을 계산하는 방법(LoC, ManMonth, COCOMO, Putnam, FP모형)
    * LoC(lines of code): sw각 기능의 원시코드 라인수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 한정한다.
    예측치: {낙관치 + (4*중간치) + 비관치} / 6
    * Man Month: 한 명이 한 달 동안 할 수 있는 일의 양을 기준으로 산정
    식 [ManMonth = LoC / 프로그래머 월간 생간성], [프로젝트 기간 = ManMonth / 프로젝트 인력]
    * COCOMO(constructive cost model)
    비용산정 결과는 프로젝트 완성하는데에 필요한 맨먼쓰로 산정한다. 규모에 따라 조직형, 반 분리형, 임베디드형 으로 나뉜다.
        (1) 조직형(organic mode): 일괄 자료 처리나 과학 기술 계산용, 비지니스 자료처리 개발에 적용한다.
        (2) 반 분리형(semi-detached mode): 단순형과 임베디드형의 중간형이다. 트랜잭션 처리 시스템이나 디비 관리 시스템, 컴파일러, 인터프리터 같은 유틸 개발에 적용한다.
        (3)